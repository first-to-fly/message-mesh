name: PR Automation

on:
  pull_request:
    types: [opened, edited, synchronize, ready_for_review]
  issue_comment:
    types: [created]

jobs:
  pr-validation:
    name: PR Validation
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate PR title
        uses: amannn/action-semantic-pull-request@v5
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          types: |
            feat
            fix
            docs
            style
            refactor
            perf
            test
            chore
            ci
            build
          requireScope: false
          disallowScopes: |
            release
          subjectPattern: ^(?![A-Z]).+$
          subjectPatternError: |
            The subject "{subject}" found in the pull request title "{title}"
            didn't match the configured pattern. Please ensure that the subject
            doesn't start with an uppercase character.

      - name: Check PR description
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            const body = pr.body || '';
            const hasDescription = body.length > 50;
            const hasChecklist = body.includes('- [');
            const hasTestPlan = body.toLowerCase().includes('test');
            
            let message = '## PR Description Check üìù\n\n';
            
            if (hasDescription) {
              message += '‚úÖ PR has adequate description\n';
            } else {
              message += '‚ùå PR description is too short (minimum 50 characters)\n';
            }
            
            if (hasChecklist) {
              message += '‚úÖ PR includes checklist\n';
            } else {
              message += '‚ö†Ô∏è Consider adding a checklist for complex changes\n';
            }
            
            if (hasTestPlan) {
              message += '‚úÖ PR mentions testing\n';
            } else {
              message += '‚ö†Ô∏è Consider adding test information\n';
            }
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: message
            });

  size-labeling:
    name: PR Size Labeling
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Calculate PR size and add labels
        uses: actions/github-script@v7
        with:
          script: |
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            let additions = 0;
            let deletions = 0;
            
            files.forEach(file => {
              additions += file.additions;
              deletions += file.deletions;
            });
            
            const totalChanges = additions + deletions;
            
            // Remove existing size labels
            const { data: labels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });
            
            const sizeLabels = labels.filter(label => label.name.startsWith('size/'));
            for (const label of sizeLabels) {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                name: label.name
              });
            }
            
            // Add appropriate size label
            let sizeLabel = '';
            if (totalChanges < 10) {
              sizeLabel = 'size/XS';
            } else if (totalChanges < 30) {
              sizeLabel = 'size/S';
            } else if (totalChanges < 100) {
              sizeLabel = 'size/M';
            } else if (totalChanges < 500) {
              sizeLabel = 'size/L';
            } else {
              sizeLabel = 'size/XL';
            }
            
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: [sizeLabel]
            });
            
            // Comment with size information
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## PR Size Analysis üìè\n\n` +
                    `- **Files changed**: ${files.length}\n` +
                    `- **Lines added**: ${additions}\n` +
                    `- **Lines deleted**: ${deletions}\n` +
                    `- **Total changes**: ${totalChanges}\n` +
                    `- **Size**: ${sizeLabel}\n\n` +
                    (totalChanges > 500 ? '‚ö†Ô∏è **Large PR detected!** Consider breaking this into smaller PRs for easier review.' : '')
            });

  auto-labeling:
    name: Auto Labeling
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Auto-label based on files changed
        uses: actions/github-script@v7
        with:
          script: |
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            const labels = new Set();
            
            files.forEach(file => {
              const path = file.filename;
              
              // Documentation changes
              if (path.includes('README') || path.includes('docs/') || path.endsWith('.md')) {
                labels.add('documentation');
              }
              
              // Test changes
              if (path.includes('.test.') || path.includes('test/') || path.includes('__tests__/')) {
                labels.add('testing');
              }
              
              // CI/CD changes
              if (path.includes('.github/workflows/') || path.includes('ci')) {
                labels.add('ci/cd');
              }
              
              // Dependencies
              if (path.includes('package.json') || path.includes('bun.lockb')) {
                labels.add('dependencies');
              }
              
              // Source code changes
              if (path.includes('src/') && path.endsWith('.ts')) {
                labels.add('source-code');
              }
              
              // Configuration changes
              if (path.includes('tsconfig') || path.includes('.eslint') || path.includes('.prettier')) {
                labels.add('configuration');
              }
            });
            
            // Add labels
            if (labels.size > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: Array.from(labels)
              });
            }

  conflict-detection:
    name: Conflict Detection
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
      - name: Check for merge conflicts
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            if (pr.mergeable_state === 'dirty') {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: '‚ö†Ô∏è **Merge conflicts detected!**\n\n' +
                      'This PR has merge conflicts with the base branch. ' +
                      'Please resolve the conflicts before this PR can be merged.\n\n' +
                      '### How to resolve:\n' +
                      '1. Sync your branch with the latest changes from `main`\n' +
                      '2. Resolve any conflicts\n' +
                      '3. Push the resolved changes\n\n' +
                      '```bash\n' +
                      'git checkout main\n' +
                      'git pull origin main\n' +
                      'git checkout your-branch\n' +
                      'git merge main\n' +
                      '# Resolve conflicts\n' +
                      'git commit\n' +
                      'git push\n' +
                      '```'
              });
              
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['merge-conflict']
              });
            }

  command-handler:
    name: Command Handler
    runs-on: ubuntu-latest
    if: github.event_name == 'issue_comment' && github.event.issue.pull_request
    
    steps:
      - name: Handle PR commands
        uses: actions/github-script@v7
        with:
          script: |
            const comment = context.payload.comment.body.trim();
            const isCollaborator = ['OWNER', 'MEMBER', 'COLLABORATOR'].includes(context.payload.comment.author_association);
            
            if (!isCollaborator) {
              return;
            }
            
            // Handle /rerun command
            if (comment === '/rerun' || comment === '/rerun-ci') {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: 'üîÑ **CI Rerun Requested**\n\nTriggering a new CI run for this PR...'
              });
              
              // This will trigger workflows due to the comment
              core.setOutput('rerun', 'true');
            }
            
            // Handle /ready command
            if (comment === '/ready') {
              await github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                draft: false
              });
              
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: '‚úÖ **PR marked as ready for review**'
              });
            }
            
            // Handle /hold command
            if (comment === '/hold') {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['do-not-merge']
              });
              
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: 'üõë **PR held from merging**\n\nThis PR is now marked as "do not merge".'
              });
            }
            
            // Handle /unhold command
            if (comment === '/unhold') {
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  name: 'do-not-merge'
                });
                
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: 'üü¢ **PR unhold**\n\nThis PR is no longer held from merging.'
                });
              } catch (error) {
                if (error.status !== 404) {
                  throw error;
                }
              }
            }

  auto-assign-reviewers:
    name: Auto Assign Reviewers
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action == 'opened'
    
    steps:
      - name: Auto-assign reviewers based on CODEOWNERS
        uses: actions/github-script@v7
        with:
          script: |
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            // Simple auto-assignment logic
            const reviewers = [];
            
            // Check if this is a significant change
            const totalChanges = files.reduce((sum, file) => sum + file.additions + file.deletions, 0);
            
            // Auto-assign for significant changes (>100 lines)
            if (totalChanges > 100) {
              // Add code-review label for significant changes
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['needs-review']
              });
              
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: 'üìã **Significant changes detected**\n\n' +
                      `This PR contains ${totalChanges} lines of changes. ` +
                      'A thorough review is recommended.\n\n' +
                      '**Review checklist:**\n' +
                      '- [ ] Code quality and maintainability\n' +
                      '- [ ] Test coverage for new features\n' +
                      '- [ ] Documentation updates\n' +
                      '- [ ] Breaking changes impact\n' +
                      '- [ ] Performance considerations'
              });
            }